<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Load GLTF Example</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #f0f0f0;
        background: url(https://www.supernetworks.org/assets/img/logo.png);
        background: url(https://www.supernetworks.org/assets/img/bgs/bg-dark.png);
        background-size: cover;
        padding-top: 80px;
      }

      #bg-wrap {
        background: #110033;
        border-color: rgb(17, 24, 39);
        border-width: 24px;
        border-style: solid;
        border-radius: 24px;
        width: 800px;
        min-height: 400px;
        margin: 0 auto;
        box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.5);
      }
      #container {
        width: 800px;
        margin: 40px auto;
      }
      p {
        font-family: monospace;
        font-weight: bold;
        color: #30d5c8;
        color: #cc00cc;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="">
      <div id="container"></div>
    </div>
    <p>
      Supernetworks SPR - Raspberry Pi DevKit
    </p>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>
    const scene = new THREE.Scene()
    //scene.background = new THREE.Color(0xffffff); // Set the background color to light gray
    const camera = new THREE.PerspectiveCamera(
      100,
      window.innerWidth / window.innerHeight,
      0.01,
      1000
    )
    const renderer = new THREE.WebGLRenderer({ alpha: true })
    renderer.setSize(window.innerWidth, window.innerHeight)

    renderer.setPixelRatio(window.devicePixelRatio)
    let w = 800,
      h = w / (window.outerWidth / window.outerHeight)
    console.log('wh=', w, h)
    renderer.setSize(w, h)

    const container = document.getElementById('container')
    container.appendChild(renderer.domElement)


    camera.position.z = 0.2

    // Create a new point light
    const light = new THREE.PointLight(0xffffff, 1, 100)
    camera.add(light) // Add the light to the camera's children
    light.position.set(0, 0, 2)
    //scene.add(light);
    scene.add(camera)

    function setMaterial(parent, mtl) {
      parent.traverse((o) => {
        if (o.type == 'Mesh' && o.name != null) {
          o.material = mtl
        }
      })
    }

    let antenna
    let gltf
    let group

    function first_update(){
      if (!antenna || !gltf){
        return
      }
      let new_mtl = new THREE.MeshPhongMaterial({
        color: 0x323232,
        shininess: 165
      })
      new_mtl = new THREE.MeshNormalMaterial(); // Create a new MeshNormalMaterial
      new_mtl.side = THREE.DoubleSide
      setMaterial(gltf.scene, new_mtl)
      setMaterial(antenna.scene, new_mtl)

      group = new THREE.Group();
      group.add(antenna.scene)

      let x = 0
      let y = 50
      let z = 25
      let x_rot = -Math.PI/8
      group.rotation.set(x_rot, 0, 0)
      antenna.scene.position.set(x, y, z)
      group.position.set(-x, -y, -z)


      gltf.scene.attach(group)

      gltf.scene.scale.set(0.002, 0.002, 0.002) // Scale the model down to make it visible
      gltf.scene.position.set(0, 0.05, 0) // Position the model at the center of the scene
      gltf.scene.rotation.set(1.5, 0, 0) // Set the model's rotation
      gltf.scene.visible = true // Make sure the object is visible

      scene.add(gltf.scene)

      let size = 2,
        divisions = 40
      const gridHelper = new THREE.GridHelper(
        size,
        divisions,
        0xe0e0e0,
        0xe0e0e0
      )

      gridHelper.position.y = -0.025

      scene.add(gridHelper)

      const controls = new THREE.OrbitControls(camera, renderer.domElement)
      controls.target.set(0, 0, 0)
      controls.update()

    }

    let x_rot = 0
    let x_dir = 1
    let x_step = Math.PI/2000
    function tick(){
      if (!antenna || !gltf){
        return
      }

      let x = 0
      let y = 50
      let z = 25

      if (x_rot >= 0) {
        x_dir = -1
      }

      if (x_rot < -Math.PI/2) {
        x_dir = 1
      }

      x_rot += x_step * x_dir


      group.rotation.set(x_rot, 0, 0)
      antenna.scene.position.set(x, y, z)
      group.position.set(-x, -y, -z)
    }

    const loader = new THREE.GLTFLoader()
    loader.load(
      'top.gltf',
      function (in_antenna) {
    loader.load(
      'model.gltf',
      function (in_gltf) {
        console.log('loaded')
        antenna = in_antenna
        gltf = in_gltf
        first_update()
      },
      undefined,
      function (error) {
        console.error(error)
      }
    )});

    //camera.position.x = 0;
    camera.position.y = 0.2
    //camera.position.z = 0;

    function animate() {
      requestAnimationFrame(animate)
      renderer.render(scene, camera)
    }

    setInterval(tick, 10);

    animate()
    </script>
  </body>
</html>
